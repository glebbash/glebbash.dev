<title>Bip Bup Bop</title>

<script type="module">
  const X_AREAS = 3;
  const Y_AREAS = 3;
  const AREA_WIDTH = 20;
  const AREA_HEIGHT = 20;

  const TILES_X_COUNT = X_AREAS * AREA_WIDTH;
  const TILES_Y_COUNT = Y_AREAS * AREA_HEIGHT;
  const TILE_SIZE = Math.floor(
    Math.min(
      document.body.clientWidth / TILES_X_COUNT,
      document.body.clientHeight / TILES_Y_COUNT
    )
  );
  const BALL_SIZE = TILE_SIZE / 2;

  const PADDING_X = (document.body.clientWidth - TILE_SIZE * TILES_X_COUNT) / 2;
  const PADDING_Y =
    (document.body.clientHeight - TILE_SIZE * TILES_Y_COUNT) / 2;

  const AREAS_COUNT = X_AREAS * Y_AREAS;
  const AREA_COLORS = generateContrastingColors(AREAS_COUNT);

  const BALL_SPEED = 200;

  const balls = [];
  const tiles = [];

  for (let areaX = 0; areaX < X_AREAS; areaX++) {
    for (let areaY = 0; areaY < Y_AREAS; areaY++) {
      const areaIndex = areaY * X_AREAS + areaX;
      const areaColor = AREA_COLORS[areaIndex];

      for (let tileX = 0; tileX < AREA_WIDTH; tileX++) {
        const globalX = areaX * AREA_WIDTH + tileX;
        tiles[globalX] = tiles[globalX] || [];

        for (let tileY = 0; tileY < AREA_HEIGHT; tileY++) {
          const globalY = areaY * AREA_HEIGHT + tileY;

          const tile = document.createElement("div");
          tile.color = areaColor;
          tile.position = {
            x: PADDING_X + globalX * TILE_SIZE,
            y: PADDING_Y + globalY * TILE_SIZE,
          };
          tile.style.position = "absolute";
          tile.style.left = `${tile.position.x}px`;
          tile.style.top = `${tile.position.y}px`;
          tile.style.width = `${TILE_SIZE}px`;
          tile.style.height = `${TILE_SIZE}px`;
          tile.style.backgroundColor = areaColor;

          document.body.appendChild(tile);

          tiles[globalX][globalY] = tile;
        }
      }
    }
  }

  for (let areaX = 0; areaX < X_AREAS; areaX++) {
    for (let areaY = 0; areaY < Y_AREAS; areaY++) {
      const areaIndex = areaY * X_AREAS + areaX;
      const areaColor = AREA_COLORS[areaIndex];

      spawnBall();
      spawnBall();
      spawnBall();

      function spawnBall() {
        const ball = document.createElement("div");
        ball.color = areaColor;
        ball.position = {
          x:
            PADDING_X +
            areaX * AREA_WIDTH * TILE_SIZE +
            (AREA_WIDTH * TILE_SIZE - TILE_SIZE) / 2,
          y:
            PADDING_Y +
            areaY * AREA_HEIGHT * TILE_SIZE +
            (AREA_HEIGHT * TILE_SIZE - TILE_SIZE) / 2,
        };
        ball.style.position = "absolute";
        ball.style.left = `${ball.position.x}px`;
        ball.style.top = `${ball.position.y}px`;

        const angle = Math.random() * Math.PI * 2;
        ball.speed = {
          x: Math.cos(angle) * BALL_SPEED,
          y: Math.sin(angle) * BALL_SPEED,
        };

        ball.style.width = `${BALL_SIZE}px`;
        ball.style.height = `${BALL_SIZE}px`;
        ball.style.borderRadius = "50%";
        ball.style.border = `${BALL_SIZE / 4}px solid white`;
        ball.style.borderColor = getContrastingColor(areaColor);
        // document.body.appendChild(ball);

        balls.push(ball);
      }
    }
  }

  let lastTime = Date.now();

  function update(time) {
    const currentTime = Date.now();
    const dt = (currentTime - lastTime) / 1000;
    lastTime = currentTime;

    for (const ball of balls) {
      ball.position.x += ball.speed.x * dt;
      ball.position.y += ball.speed.y * dt;

      if (ball.position.x <= PADDING_X) {
        ball.speed.x *= -1;
        ball.position.x = PADDING_X;
      }
      if (
        ball.position.x + BALL_SIZE >=
        PADDING_X + TILE_SIZE * TILES_X_COUNT
      ) {
        ball.speed.x *= -1;
        ball.position.x = PADDING_X + TILE_SIZE * TILES_X_COUNT - BALL_SIZE;
      }

      if (ball.position.y <= PADDING_Y) {
        ball.speed.y *= -1;
        ball.position.y = PADDING_Y;
      }
      if (
        ball.position.y + BALL_SIZE >=
        PADDING_Y + TILE_SIZE * TILES_Y_COUNT
      ) {
        ball.speed.y *= -1;
        ball.position.y = PADDING_Y + TILE_SIZE * TILES_Y_COUNT - BALL_SIZE;
      }

      check: for (let tileX = 0; tileX < TILES_X_COUNT; tileX++) {
        for (let tileY = 0; tileY < TILES_Y_COUNT; tileY++) {
          const tile = tiles[tileX][tileY];

          if (tile.color !== ball.color) {
            const tileLeft = tile.position.x;
            const tileTop = tile.position.y;
            const tileRight = tileLeft + TILE_SIZE;
            const tileBottom = tileTop + TILE_SIZE;

            const ballLeft = ball.position.x;
            const ballTop = ball.position.y;
            const ballRight = ballLeft + BALL_SIZE;
            const ballBottom = ballTop + BALL_SIZE;

            // Check if the ball overlaps with the tile
            if (
              ballRight > tileLeft &&
              ballLeft < tileRight &&
              ballBottom > tileTop &&
              ballTop < tileBottom
            ) {
              let collided = false;

              const ballCenterX = ball.position.x + BALL_SIZE / 2;
              const ballCenterY = ball.position.y + BALL_SIZE / 2;
              const tileCenterX = tile.position.x + TILE_SIZE / 2;
              const tileCenterY = tile.position.y + TILE_SIZE / 2;

              if (ballCenterX < tileCenterX && ball.speed.x > 0) {
                ball.speed.x *= -1;
                // ball.position.x = tile.position.x - BALL_SIZE;
                collided = true;
              } else if (ballCenterX > tileCenterX && ball.speed.x < 0) {
                ball.speed.x *= -1;
                // ball.position.x = tile.position.x + TILE_SIZE;
                collided = true;
              }

              if (ballCenterY < tileCenterY && ball.speed.y > 0) {
                ball.speed.y *= -1;
                // ball.position.y = tile.position.y - BALL_SIZE;
                collided = true;
              } else if (ballCenterY > tileCenterY && ball.speed.y < 0) {
                ball.speed.y *= -1;
                // ball.position.y = tile.position.y + TILE_SIZE;
                collided = true;
              }

              if (collided) {
                tile.color = ball.color;
                tile.style.backgroundColor = ball.color;
                // break check;
              }
            }
          }
        }
      }

      ball.style.left = `${ball.position.x}px`;
      ball.style.top = `${ball.position.y}px`;
    }

    requestAnimationFrame(update);
  }

  requestAnimationFrame(update);

  document.body.style.backgroundColor = "black";

  function generateRandomColor() {
    return `#${Math.floor(Math.random() * 16777215)
      .toString(16)
      .padStart(6, "0")}`;
  }

  function getContrastingColor(hex) {
    hex = hex.replace("#", "");

    const r = parseInt(hex.substring(0, 2), 16);
    const g = parseInt(hex.substring(2, 4), 16);
    const b = parseInt(hex.substring(4, 6), 16);

    const luminance =
      0.2126 * (r / 255) + 0.7152 * (g / 255) + 0.0722 * (b / 255);

    return luminance > 0.5 ? "#000000" : "#FFFFFF";
  }

  function generateContrastingColors(numColors) {
    const colors = [];

    // Generate random colors with distinct hues
    for (let i = 0; i < numColors; i++) {
      // Generate a hue value that's spaced apart to ensure contrast
      let hue = ((i * 360) / numColors + Math.random() * 30) % 360; // Slight randomness in hue for more variation
      let saturation = 70 + Math.random() * 30; // Random saturation between 70 and 100
      let lightness = 40 + Math.random() * 30; // Random lightness between 40 and 70

      // Convert HSL to HEX
      let color = hslToHex(hue, saturation, lightness);
      colors.push(color);
    }

    return colors;
  }

  // HSL to HEX conversion function
  function hslToHex(h, s, l) {
    s /= 100;
    l /= 100;

    const c = (1 - Math.abs(2 * l - 1)) * s;
    const x = c * (1 - Math.abs(((h / 60) % 2) - 1));
    const m = l - c / 2;

    let r = 0,
      g = 0,
      b = 0;
    if (h >= 0 && h < 60) {
      r = c;
      g = x;
      b = 0;
    } else if (h >= 60 && h < 120) {
      r = x;
      g = c;
      b = 0;
    } else if (h >= 120 && h < 180) {
      r = 0;
      g = c;
      b = x;
    } else if (h >= 180 && h < 240) {
      r = 0;
      g = x;
      b = c;
    } else if (h >= 240 && h < 300) {
      r = x;
      g = 0;
      b = c;
    } else if (h >= 300 && h < 360) {
      r = c;
      g = 0;
      b = x;
    }

    // Convert RGB to HEX
    function rgbToHex(value) {
      const hex = Math.round((value + m) * 255).toString(16);
      return hex.length === 1 ? "0" + hex : hex;
    }

    return `#${rgbToHex(r)}${rgbToHex(g)}${rgbToHex(b)}`;
  }
</script>
