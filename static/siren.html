<!DOCTYPE html>

<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Police Siren WebGL2</title>
<style>
  html,
  body {
    margin: 0;
  }
  body {
    background: black;
    padding: auto;
    display: flex;
    align-items: center;
    justify-content: center;
    height: 100vh;
    margin: 0;
    overflow: hidden;
  }
  canvas {
    display: block;
    background: black;
    width: 100%;
    height: 100%;
  }
</style>

<canvas id="canvas"></canvas>
<script>
  // @ts-check

  /** @type {HTMLCanvasElement} */
  let canvas;

  /** @type {WebGL2RenderingContext} */
  let gl;

  const UNIFORM_LOC_NULL = /** @type {WebGLUniformLocation | null} */ (null);

  const uniforms = {
    time: { value: 0.0, loc: UNIFORM_LOC_NULL },
    resolution: { value: [0.0, 0.0], loc: UNIFORM_LOC_NULL },
  };

  main().catch(alert);

  async function main() {
    canvas = document.querySelector("#canvas") ?? panic("no #canvas");
    gl = canvas.getContext("webgl2") ?? panic("WebGL2 not supported");

    resize();
    window.addEventListener("resize", resize);

    const vertShader = await loadShader(
      gl.VERTEX_SHADER,
      `#version 300 es

      in vec2 a_position;
      out vec2 v_vertex;

      void main() {
        v_vertex = a_position;
        gl_Position = vec4(a_position, 0, 1);
      }
      `
    );
    const fragShader = await loadShader(
      gl.FRAGMENT_SHADER,
      `#version 300 es

      precision highp float;

      uniform vec2 u_resolution;
      uniform float u_time;

      in vec2 v_vertex;
      out vec4 o_color;

      const float radius = 0.3;
      const float slowness = 100.0;

      void main() {
        bool red = int(u_time / (4.0 * slowness)) % 2 == 1;
        float offset = -8.0 + mod(u_time, 4.0 * slowness) / slowness;

        o_color = vec4(0, 0, 0, 1);
        if (red) {
          o_color.r = cos(v_vertex.x + offset);
        } else {
          o_color.b = cos(v_vertex.x + offset);
        }

        vec2 v = v_vertex * u_resolution / min(u_resolution.x, u_resolution.y);

        float dist = distance(v, vec2(0));
        float brightness = dist / radius;
        o_color /= brightness;
      }
      `
    );
    const program = linkShaderProgram([vertShader, fragShader]);

    uniforms.time.loc = gl.getUniformLocation(program, "u_time");
    uniforms.resolution.loc = gl.getUniformLocation(program, "u_resolution");

    gl.useProgram(program);

    const positionAttrLoc = gl.getAttribLocation(program, "a_position");
    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(
      gl.ARRAY_BUFFER,
      new Float32Array([-1, -1, 1, -1, 1, 1, 1, 1, -1, 1, -1, -1]),
      gl.STATIC_DRAW
    );
    const vao = gl.createVertexArray();
    gl.bindVertexArray(vao);
    gl.enableVertexAttribArray(positionAttrLoc);
    gl.vertexAttribPointer(positionAttrLoc, 2, gl.FLOAT, false, 0, 0);

    render(0);
  }

  /** @param {number} timestamp */
  function render(timestamp) {
    window.requestAnimationFrame(render);

    uniforms.resolution.value = [gl.canvas.width, gl.canvas.height];
    gl.uniform2fv(uniforms.resolution.loc, uniforms.resolution.value);

    uniforms.time.value = timestamp;
    gl.uniform1f(uniforms.time.loc, uniforms.time.value);

    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    gl.clearColor(0, 0, 0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
  }

  function resize() {
    canvas.width = canvas.clientWidth;
    canvas.height = canvas.clientHeight;
  }

  // utils

  /**
   * @param {WebGLShader[]} shaders
   */
  function linkShaderProgram(shaders) {
    const program = gl.createProgram();
    for (const shader of shaders) {
      gl.attachShader(program, shader);
    }
    gl.linkProgram(program);

    const success = gl.getProgramParameter(program, gl.LINK_STATUS);
    if (!success) {
      const errMessage =
        gl.getProgramInfoLog(program) ?? "unknown error linking program";
      gl.deleteProgram(program);
      throw new Error(errMessage);
    }

    return program;
  }

  /**
   * @param {GLenum} type
   * @param {string} source
   */
  async function loadShader(type, source) {
    const shader = gl.createShader(type) ?? panic("can't create shader");
    gl.shaderSource(shader, source);
    gl.compileShader(shader);

    const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
    if (!success) {
      const errMessage =
        gl.getShaderInfoLog(shader) ?? "unknown error compiling shader";
      gl.deleteShader(shader);
      throw new Error(errMessage);
    }

    return shader;
  }

  /**
   * @param {string} message
   * @returns {never}
   */
  function panic(message) {
    throw new Error(message);
  }
</script>
